diff -ruN TLS-Attacker/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/dtls/FragmentManager.java TLS-Attacker_patched/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/dtls/FragmentManager.java
--- TLS-Attacker/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/dtls/FragmentManager.java	2025-02-08 16:56:41.298359978 +0100
+++ TLS-Attacker_patched/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/dtls/FragmentManager.java	2025-02-08 02:35:10.080387775 +0100
@@ -23,7 +23,6 @@
 
     private Map<FragmentKey, FragmentCollector> fragments;
     private Config config;
-    private int lastInterpretedMessageSeq = -1;
 
     public FragmentManager(Config config) {
         fragments = new HashMap<>();
@@ -69,21 +68,6 @@
             boolean onlyIfComplete, boolean skipMessageSequences) {
         List<DtlsHandshakeMessageFragment> handshakeFragmentList = new LinkedList<>();
         List<FragmentKey> orderedFragmentKeys = new ArrayList<>(fragments.keySet());
-        orderedFragmentKeys.sort(
-                new Comparator<FragmentKey>() {
-                    @Override
-                    public int compare(FragmentKey fragmentKey1, FragmentKey fragmentKey2) {
-                        if (fragmentKey1.getEpoch() > fragmentKey2.getEpoch()) {
-                            return -1;
-                        } else if (fragmentKey1.getEpoch() < fragmentKey2.getEpoch()) {
-                            return 1;
-                        } else {
-                            return fragmentKey1
-                                    .getMessageSeq()
-                                    .compareTo(fragmentKey2.getMessageSeq());
-                        }
-                    }
-                });
 
         for (FragmentKey key : orderedFragmentKeys) {
             FragmentCollector fragmentCollector = fragments.get(key);
@@ -100,11 +84,6 @@
                 }
             }
             if (!fragmentCollector.isInterpreted()) {
-                if (!skipMessageSequences
-                        && key.getMessageSeq() != lastInterpretedMessageSeq + 1
-                        && !fragmentCollector.isRetransmission()) {
-                    break;
-                }
                 if (onlyIfComplete && !fragmentCollector.isMessageComplete()) {
                     LOGGER.debug(
                             "Incomplete message. Not processing: msg_sqn: "
@@ -114,7 +93,7 @@
                 } else {
                     handshakeFragmentList.add(fragmentCollector.buildCombinedFragment());
                     fragmentCollector.setInterpreted(true);
-                    lastInterpretedMessageSeq = key.getMessageSeq();
+                    clearFragmentedMessage(key.getMessageSeq(), key.getEpoch());
                 }
             }
         }
diff -ruN TLS-Attacker/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/layer/LayerStackFactory.java TLS-Attacker_patched/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/layer/LayerStackFactory.java
--- TLS-Attacker/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/layer/LayerStackFactory.java	2025-02-06 01:00:52.196179597 +0100
+++ TLS-Attacker_patched/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/layer/LayerStackFactory.java	2025-02-11 13:39:58.499641217 +0100
@@ -32,7 +32,7 @@
                         new MessageLayer(context),
                         new DtlsFragmentLayer(context),
                         new RecordLayer(context),
-                        new UdpLayer(context));
+                        new FirstCachedUdpLayer(context));
             case QUIC:
                 return new LayerStack(
                         context,
diff -ruN TLS-Attacker/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/layer/context/TlsContext.java TLS-Attacker_patched/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/layer/context/TlsContext.java
--- TLS-Attacker/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/layer/context/TlsContext.java	2025-02-08 02:29:25.443282294 +0100
+++ TLS-Attacker_patched/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/layer/context/TlsContext.java	2025-02-08 17:31:48.355691568 +0100
@@ -60,6 +60,7 @@
 import de.rub.nds.tlsattacker.core.state.session.TicketSession;
 import de.rub.nds.tlsattacker.core.workflow.chooser.Chooser;
 import de.rub.nds.tlsattacker.transport.ConnectionEndType;
+import de.rub.nds.x509attacker.constants.X509PublicKeyType;
 import de.rub.nds.x509attacker.context.X509Context;
 import de.rub.nds.x509attacker.x509.X509CertificateChain;
 import jakarta.xml.bind.annotation.XmlAccessType;
@@ -73,6 +74,7 @@
 import java.util.List;
 import java.util.Random;
 import java.util.Set;
+import org.apache.commons.lang3.NotImplementedException;
 
 /** Holds all runtime variables of the TLSLayer. */
 @XmlAccessorType(XmlAccessType.FIELD)
@@ -522,6 +524,60 @@
         context.setTlsContext(this);
         init();
     }
+
+    public TlsContext(Context context, Config config) {
+        super(context);
+        clientX509Context = new X509Context();
+        serverX509Context = new X509Context();
+
+        X509PublicKeyType publicKeyType =
+                config.getCertificateChainConfig().get(0).getPublicKeyType();
+        if (publicKeyType == X509PublicKeyType.RSA) {
+            // Client RSA
+            clientX509Context.setSubjectRsaModulus(
+                    config.getCertificateChainConfig().get(0).getRsaModulus());
+            clientX509Context.setSubjectRsaPrivateKey(
+                    config.getCertificateChainConfig().get(0).getRsaPrivateKey());
+            clientX509Context.setSubjectRsaPublicExponent(
+                    config.getCertificateChainConfig().get(0).getRsaPublicExponent());
+            // Server RSA
+            serverX509Context.setSubjectRsaModulus(
+                    config.getCertificateChainConfig().get(0).getRsaModulus());
+            serverX509Context.setSubjectRsaPrivateKey(
+                    config.getCertificateChainConfig().get(0).getRsaPrivateKey());
+            serverX509Context.setSubjectRsaPublicExponent(
+                    config.getCertificateChainConfig().get(0).getRsaPublicExponent());
+        } else if (publicKeyType == X509PublicKeyType.ECDH_ECDSA) {
+            // Client EC
+            clientX509Context.setSubjectEcPrivateKey(
+                    config.getCertificateChainConfig().get(0).getEcPrivateKey());
+            clientX509Context.setSubjectEcPublicKey(
+                    config.getCertificateChainConfig().get(0).getEcPublicKey());
+            clientX509Context.setSubjectNamedCurve(
+                    config.getCertificateChainConfig().get(0).getDefaultSubjectNamedCurve());
+            clientX509Context.setSubjectPublicKeyType(
+                    config.getCertificateChainConfig().get(0).getPublicKeyType());
+            clientX509Context.setSubjectSignatureAlgorithm(
+                    config.getCertificateChainConfig().get(0).getDefaultSignatureAlgorithm());
+            // Server EC
+            serverX509Context.setSubjectEcPrivateKey(
+                    config.getCertificateChainConfig().get(0).getEcPrivateKey());
+            serverX509Context.setSubjectEcPublicKey(
+                    config.getCertificateChainConfig().get(0).getEcPublicKey());
+            serverX509Context.setSubjectNamedCurve(
+                    config.getCertificateChainConfig().get(0).getDefaultSubjectNamedCurve());
+            serverX509Context.setSubjectPublicKeyType(
+                    config.getCertificateChainConfig().get(0).getPublicKeyType());
+            serverX509Context.setSubjectSignatureAlgorithm(
+                    config.getCertificateChainConfig().get(0).getDefaultSignatureAlgorithm());
+        } else {
+            throw new NotImplementedException(
+                    "You may forget to add corresponding patch for TLS-Attacker publicKeyType: "
+                            + publicKeyType.name());
+        }
+        context.setTlsContext(this);
+        init();
+    }
 
     public List<SrtpProtectionProfile> getClientSupportedSrtpProtectionProfiles() {
         return this.clientSupportedSrtpProtectionProfiles;
diff -ruN TLS-Attacker/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/layer/impl/FirstCachedUdpLayer.java TLS-Attacker_patched/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/layer/impl/FirstCachedUdpLayer.java
--- TLS-Attacker/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/layer/impl/FirstCachedUdpLayer.java	1970-01-01 01:00:00.000000000 +0100
+++ TLS-Attacker_patched/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/layer/impl/FirstCachedUdpLayer.java	2025-02-11 14:55:54.898535062 +0100
@@ -0,0 +1,64 @@
+/*
+ * TLS-Attacker - A Modular Penetration Testing Framework for TLS
+ *
+ * Copyright 2014-2023 Ruhr University Bochum, Paderborn University, Technology Innovation Institute, and Hackmanit GmbH
+ *
+ * Licensed under Apache License, Version 2.0
+ * http://www.apache.org/licenses/LICENSE-2.0.txt
+ */
+package de.rub.nds.tlsattacker.core.layer.impl;
+
+import de.rub.nds.tlsattacker.core.layer.hints.LayerProcessingHint;
+import de.rub.nds.tlsattacker.core.layer.stream.HintedLayerInputStream;
+import de.rub.nds.tlsattacker.core.state.Context;
+import de.rub.nds.tlsattacker.core.udp.UdpDataPacket;
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+
+/**
+ * The UDP layer is a wrapper around an underlying UDP socket. It forwards the sockets InputStream
+ * for reading and sends any data over the UDP layer without modifications.
+ */
+public class FirstCachedUdpLayer extends UdpLayer {
+
+    private byte[] firstClientHello = null;
+    private boolean isFirstClientHelloConsumed = false;
+
+    public boolean isFuzzingClient = false;
+
+    public FirstCachedUdpLayer(Context context) {
+        super(context);
+    }
+
+    public void setFirstClientHelo(byte[] bytes) {
+        this.firstClientHello = bytes;
+    }
+
+    public byte[] getFirstClientHelo() {
+        return this.firstClientHello;
+    }
+
+    @Override
+    public void receiveMoreDataForHint(LayerProcessingHint hint) throws IOException {
+        byte[] receivedPacket = null;
+        if (!isFirstClientHelloConsumed && isFuzzingClient) {
+            receivedPacket = firstClientHello;
+            isFirstClientHelloConsumed = true;
+        } else {
+            receivedPacket = getTransportHandler().fetchData();
+        }
+        UdpDataPacket udpDataPacket = new UdpDataPacket();
+        udpDataPacket
+                .getParser(context, new ByteArrayInputStream(receivedPacket))
+                .parse(udpDataPacket);
+        udpDataPacket.getPreparator(context).prepareAfterParse();
+        udpDataPacket.getHandler(context).adjustContext(udpDataPacket);
+        addProducedContainer(udpDataPacket);
+        if (currentInputStream == null) {
+            currentInputStream = new HintedLayerInputStream(null, this);
+            currentInputStream.extendStream(receivedPacket);
+        } else {
+            currentInputStream.extendStream(receivedPacket);
+        }
+    }
+}
diff -ruN TLS-Attacker/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/layer/impl/UdpLayer.java TLS-Attacker_patched/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/layer/impl/UdpLayer.java
--- TLS-Attacker/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/layer/impl/UdpLayer.java	2025-02-06 01:00:52.196179597 +0100
+++ TLS-Attacker_patched/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/layer/impl/UdpLayer.java	2025-02-11 11:48:34.040163959 +0100
@@ -26,7 +26,7 @@
  */
 public class UdpLayer extends ProtocolLayer<LayerProcessingHint, UdpDataPacket> {
 
-    private final Context context;
+    protected final Context context;
 
     public UdpLayer(Context context) {
         super(ImplementedLayers.UDP);
@@ -88,7 +88,7 @@
         return new LayerProcessingResult<UdpDataPacket>(null, getLayerType(), true);
     }
 
-    private UdpTransportHandler getTransportHandler() {
+    protected UdpTransportHandler getTransportHandler() {
         if (context.getTransportHandler() == null) {
             throw new RuntimeException("TransportHandler is not set in context!");
         }
diff -ruN TLS-Attacker/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/protocol/preparator/CertificateMessagePreparator.java TLS-Attacker_patched/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/protocol/preparator/CertificateMessagePreparator.java
--- TLS-Attacker/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/protocol/preparator/CertificateMessagePreparator.java	2025-02-08 02:29:25.443282294 +0100
+++ TLS-Attacker_patched/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/protocol/preparator/CertificateMessagePreparator.java	2025-02-08 22:50:18.692731360 +0100
@@ -114,7 +114,8 @@
 
             case X509:
                 List<CertificateEntry> entryList = msg.getCertificateEntryList();
-                if (chooser.getConfig().getDefaultExplicitCertificateChain() == null) {
+                if (chooser.getConfig().getDefaultExplicitCertificateChain() == null
+                        || entryList != null) {
                     if (entryList == null) {
                         if (chooser.getConfig().getAutoAdjustCertificate()) {
                             X509PublicKeyType[] certificateKeyTypes =
@@ -223,7 +224,6 @@
                 prepareCert(entryList, x509Context, certConfig, i);
             }
         }
-        chooser.getContext().getTlsContext().setTalkingX509Context(x509Context);
     }
 
     private void prepareCert(
diff -ruN TLS-Attacker/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/protocol/preparator/RSAClientKeyExchangePreparator.java TLS-Attacker_patched/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/protocol/preparator/RSAClientKeyExchangePreparator.java
--- TLS-Attacker/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/protocol/preparator/RSAClientKeyExchangePreparator.java	2025-02-06 01:00:52.325833970 +0100
+++ TLS-Attacker_patched/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/protocol/preparator/RSAClientKeyExchangePreparator.java	2025-02-13 18:18:34.365445319 +0100
@@ -144,7 +144,7 @@
     public byte[] decryptPremasterSecret() {
         BigInteger bigIntegerEncryptedPremasterSecret =
                 new BigInteger(1, msg.getPublicKey().getValue());
-        BigInteger serverPrivateKey = chooser.getServerX509Chooser().getConfig().getRsaPrivateKey();
+        BigInteger serverPrivateKey = chooser.getServerX509Chooser().getSubjectRsaPrivateKey();
         if (chooser.getServerX509Chooser().getSubjectRsaModulus().equals(BigInteger.ZERO)) {
             LOGGER.warn("RSA modulus is zero, returning new byte[0] as decryptedPremasterSecret");
             return new byte[0];
diff -ruN TLS-Attacker/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/state/Context.java TLS-Attacker_patched/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/state/Context.java
--- TLS-Attacker/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/state/Context.java	2025-02-08 02:29:25.443282294 +0100
+++ TLS-Attacker_patched/TLS-Core/src/main/java/de/rub/nds/tlsattacker/core/state/Context.java	2025-02-08 00:57:42.272011120 +0100
@@ -168,7 +168,7 @@
     }
 
     public void prepareWithLayers(StackConfiguration type) {
-        tlsContext = new TlsContext(this);
+        tlsContext = new TlsContext(this, config);
         httpContext = new HttpContext(this);
         tcpContext = new TcpContext(this);
         quicContext = new QuicContext(this);
